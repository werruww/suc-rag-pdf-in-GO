# -*- coding: utf-8 -*-
"""suc_ask_pdf_inGO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HobdKKIpmTRIwEjbvXmlYkz2rXgoHbc0
"""









"""شغال########################"""

!wget https://go.dev/dl/go1.24.3.linux-amd64.tar.gz
!tar -C /usr/local -xzf go1.24.3.linux-amd64.tar.gz

import os
os.environ['PATH'] += ":/usr/local/go/bin"

!go version

"""@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"""











curl -fsSL https://ollama.com/install.sh | sh
nohup ollama serve &
ollama pull llama3:8b
ollama list

!curl -fsSL https://ollama.com/install.sh | sh

!nohup ollama serve &

!ollama run mistral:7b-instruct-q2_K

!nohup ollama serve &
!ollama list







"""يكتب تقرير عن موضوع ويحفظه فى pdf"""

/content/1.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/jung-kurt/gofpdf"
)

// توليد النص باستخدام Ollama API
func generateText(prompt, model string) (string, error) {
	url := "http://localhost:11434/api/generate"

	requestBody := map[string]interface{}{
		"model":  model,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return "", err
	}

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	responseText, ok := result["response"].(string)
	if !ok {
		return "", fmt.Errorf("invalid response format")
	}

	return responseText, nil
}

// إنشاء ملف PDF
func createPDF(content, filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Arial", "", 12)

	// إضافة المحتوى إلى PDF
	pdf.MultiCell(0, 10, content, "", "", false)

	// حفظ الملف
	return pdf.OutputFileAndClose(filename)
}

func main() {
	// إعداد المُدخلات
	prompt := "Write a detailed report about renewable energy trends in 2024."
	model := "mistral:7b-instruct-q2_K" // أو أي نموذج آخر متوفر

	// توليد النص
	generatedText, err := generateText(prompt, model)
	if err != nil {
		log.Fatalf("خطأ في توليد النص: %v", err)
	}

	// إنشاء PDF
	err = createPDF(generatedText, "report.pdf")
	if err != nil {
		log.Fatalf("خطأ في إنشاء الملف: %v", err)
	}

	fmt.Println("تم إنشاء التقرير بنجاح: report.pdf")
}



from google.colab import drive
drive.mount('/content/drive')

!go run 1.go

# Commented out IPython magic to ensure Python compatibility.
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
)

const (
	ollamaUrl = "http://localhost:11434/api/generate"
	modelName = "mistral:7b-instruct-q2_K" // أو أي نموذج مدعوم
	bookFile  = "1.txt" // ملف النص الخاص بالكتاب
)

// تحميل محتوى الكتاب من ملف
func loadBookContent() (string, error) {
	content, err := os.ReadFile(bookFile)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// توليد الردود باستخدام Ollama
func generateResponse(question, context string) (string, error) {
	prompt := fmt.Sprintf(`استخدم المعلومات التالية من الكتاب للإجابة على السؤال:
# %s

السؤال: %s
الإجابة:`, context, question)

	requestBody := map[string]interface{}{
		"model":  modelName,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, _ := json.Marshal(requestBody)
	resp, err := http.Post(ollamaUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	return result["response"].(string), nil
}

// تشغيل واجهة الشات
func runChatSession(bookContent string) {
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Println("\nمرحبًا! يمكنك طرح أسئلة عن الكتاب. اكتب 'خروج' للإنهاء.")

	for {
		fmt.Print("\nأنت: ")
		scanner.Scan()
		question := scanner.Text()

		if strings.ToLower(question) == "خروج" {
			break
		}

		response, err := generateResponse(question, bookContent)
		if err != nil {
			log.Printf("خطأ في توليد الرد: %v", err)
			continue
		}

		fmt.Printf("\nالبوت: %s\n", response)
	}
}

func main() {
	// تحميل محتوى الكتاب
	bookContent, err := loadBookContent()
	if err != nil {
		log.Fatalf("خطأ في قراءة الملف: %v", err)
	}

	// بدء جلسة الحوار
	runChatSession(bookContent)
}

!go mod init mymodule

!go get github.com/jung-kurt/gofpdf

"""شغال انشاء كتاب حول موضوع معين"""

/content/1.go
package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"

	"github.com/jung-kurt/gofpdf"
)

// توليد النص باستخدام Ollama API
func generateText(prompt, model string) (string, error) {
	url := "http://localhost:11434/api/generate"

	requestBody := map[string]interface{}{
		"model":  model,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, err := json.Marshal(requestBody)
	if err != nil {
		return "", err
	}

	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	responseText, ok := result["response"].(string)
	if !ok {
		return "", fmt.Errorf("invalid response format")
	}

	return responseText, nil
}

// إنشاء ملف PDF
func createPDF(content, filename string) error {
	pdf := gofpdf.New("P", "mm", "A4", "")
	pdf.AddPage()
	pdf.SetFont("Arial", "", 12)

	// إضافة المحتوى إلى PDF
	pdf.MultiCell(0, 10, content, "", "", false)

	// حفظ الملف
	return pdf.OutputFileAndClose(filename)
}

func main() {
	// إعداد المُدخلات
	prompt := "Write a detailed report about renewable energy trends in 2024."
	model := "mistral:7b-instruct-q2_K" // أو أي نموذج آخر متوفر

	// توليد النص
	generatedText, err := generateText(prompt, model)
	if err != nil {
		log.Fatalf("خطأ في توليد النص: %v", err)
	}

	// إنشاء PDF
	err = createPDF(generatedText, "report.pdf")
	if err != nil {
		log.Fatalf("خطأ في إنشاء الملف: %v", err)
	}

	fmt.Println("تم إنشاء التقرير بنجاح: report.pdf")
}

!go mod init pdf-generator
!go get github.com/jung-kurt/gofpdf
!go run 1.go

!go get github.com/jung-kurt/gofpdf













"""شغال راج لكن مع ملف نصى اقصصر من 4000 كلمة"""

# Commented out IPython magic to ensure Python compatibility.
/content/2.go
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
)

const (
	ollamaUrl = "http://localhost:11434/api/generate"
	modelName = "mistral:7b-instruct-q2_K" // أو أي نموذج مدعوم
	bookFile  = "1.txt" // ملف النص الخاص بالكتاب
)

// تحميل محتوى الكتاب من ملف
func loadBookContent() (string, error) {
	content, err := os.ReadFile(bookFile)
	if err != nil {
		return "", err
	}
	return string(content), nil
}

// توليد الردود باستخدام Ollama
func generateResponse(question, context string) (string, error) {
	prompt := fmt.Sprintf(`استخدم المعلومات التالية من الكتاب للإجابة على السؤال:
# %s

السؤال: %s
الإجابة:`, context, question)

	requestBody := map[string]interface{}{
		"model":  modelName,
		"prompt": prompt,
		"stream": false,
	}

	jsonData, _ := json.Marshal(requestBody)
	resp, err := http.Post(ollamaUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	return result["response"].(string), nil
}

// تشغيل واجهة الشات
func runChatSession(bookContent string) {
	scanner := bufio.NewScanner(os.Stdin)
	fmt.Println("\nمرحبًا! يمكنك طرح أسئلة عن الكتاب. اكتب 'خروج' للإنهاء.")

	for {
		fmt.Print("\nأنت: ")
		scanner.Scan()
		question := scanner.Text()

		if strings.ToLower(question) == "خروج" {
			break
		}

		response, err := generateResponse(question, bookContent)
		if err != nil {
			log.Printf("خطأ في توليد الرد: %v", err)
			continue
		}

		fmt.Printf("\nالبوت: %s\n", response)
	}
}

func main() {
	// تحميل محتوى الكتاب
	bookContent, err := loadBookContent()
	if err != nil {
		log.Fatalf("خطأ في قراءة الملف: %v", err)
	}

	// بدء جلسة الحوار
	runChatSession(bookContent)
}

!go run 2.go

!nohup ollama serve &

!go run 2.go









!ollama pull nomic-embed-text

!nohup ollama serve &
!ollama list

!go get github.com/unidoc/unidoc/pdf
!go get github.com/ynqa/wego

!sudo apt-get install poppler-utils

"""### شغال شات مع pdf"""

# Commented out IPython magic to ensure Python compatibility.
/content/4.go
package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"net/http"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

const (
	chunkSize    = 500
	maxChunks    = 100
	ollamaUrl    = "http://localhost:11434/api/generate"
	embedderUrl  = "http://localhost:11434/api/embeddings"
	modelName    = "mistral:7b-instruct-q2_K"
	embedderName = "nomic-embed-text:latest"
)

type EmbeddingChunk struct {
	Text      string
	Embedding []float32
}

var chunks []EmbeddingChunk

func extractTextFromPDF(path string) (string, error) {
	cmd := exec.Command("pdftotext", "-q", path, "-")
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("pdftotext error: %v", err)
	}
	return cleanText(out.String()), nil
}

func cleanText(text string) string {
	text = regexp.MustCompile(`[\x{000d}\x{000c}\x{000a}]+`).ReplaceAllString(text, " ")
	text = regexp.MustCompile(`\s+`).ReplaceAllString(text, " ")
	return strings.TrimSpace(text)
}

func splitText(text string) []string {
	words := strings.Fields(text)
	var chunks []string
	currentChunk := strings.Builder{}

	for _, word := range words {
		if currentChunk.Len()+len(word) > chunkSize {
			chunks = append(chunks, currentChunk.String())
			currentChunk.Reset()
			if len(chunks) >= maxChunks {
				break
			}
		}
		currentChunk.WriteString(word + " ")
	}

	if currentChunk.Len() > 0 {
		chunks = append(chunks, currentChunk.String())
	}

	return chunks
}

func generateEmbeddings(text string) ([]float32, error) {
	requestBody := map[string]interface{}{
		"model":  embedderName,
		"prompt": text,
	}

	jsonData, _ := json.Marshal(requestBody)
	resp, err := http.Post(embedderUrl, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result struct {
		Embedding []float32 `json:"embedding"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result.Embedding, nil
}

func cosineSimilarity(a, b []float32) float32 {
	var dot, magA, magB float32
	for i := range a {
		dot += a[i] * b[i]
		magA += a[i] * a[i]
		magB += b[i] * b[i]
	}
	return dot / (float32(math.Sqrt(float64(magA))) * float32(math.Sqrt(float64(magB))))
}

func findRelevantChunks(query string, topK int) []string {
	queryEmbedding, err := generateEmbeddings(query)
	if err != nil {
		return nil
	}

	type scoredChunk struct {
		text  string
		score float32
	}

	var scoredChunks []scoredChunk
	for _, chunk := range chunks {
		score := cosineSimilarity(queryEmbedding, chunk.Embedding)
		scoredChunks = append(scoredChunks, scoredChunk{
			text:  chunk.Text,
			score: score,
		})
	}

	// Sort by score descending
	for i := 0; i < len(scoredChunks); i++ {
		for j := i + 1; j < len(scoredChunks); j++ {
			if scoredChunks[i].score < scoredChunks[j].score {
				scoredChunks[i], scoredChunks[j] = scoredChunks[j], scoredChunks[i]
			}
		}
	}

	var bestChunks []string
	for i := 0; i < topK && i < len(scoredChunks); i++ {
		bestChunks = append(bestChunks, scoredChunks[i].text)
	}

	return bestChunks
}

func main() {
	text, err := extractTextFromPDF("Understanding_Climate_Change.pdf")
	if err != nil {
		log.Fatal(err)
	}

	textChunks := splitText(text)

	for _, chunk := range textChunks {
		embedding, err := generateEmbeddings(chunk)
		if err != nil {
			log.Printf("Embedding generation error: %v", err)
			continue
		}
		chunks = append(chunks, EmbeddingChunk{
			Text:      chunk,
			Embedding: embedding,
		})
	}

	scanner := bufio.NewScanner(os.Stdin)
	fmt.Println("مرحبًا! اطرح أسئلة عن الكتاب (اكتب 'خروج' للإنهاء):")

	for {
		fmt.Print("\nأنت: ")
		scanner.Scan()
		query := scanner.Text()

		if strings.ToLower(query) == "خروج" {
			break
		}

		contextChunks := findRelevantChunks(query, 3)
		context := strings.Join(contextChunks, "\n")

		prompt := fmt.Sprintf(`استخدم السياق التالي للإجابة على السؤال:
# %s

السؤال: %s
الإجابة:`, context, query)

		requestBody := map[string]interface{}{
			"model":  modelName,
			"prompt": prompt,
			"stream": false,
		}

		jsonData, _ := json.Marshal(requestBody)
		resp, err := http.Post(ollamaUrl, "application/json", bytes.NewBuffer(jsonData))
		if err != nil {
			log.Printf("API error: %v", err)
			continue
		}
		defer resp.Body.Close()

		var result map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
			log.Printf("Response error: %v", err)
			continue
		}

		fmt.Printf("\nالبوت: %s\n", result["response"])
	}
}

!go run 4.go

